# 11.26  Поднятие и размещение

Следующая демонстрация добавляет другой объект, который мы хотим чтобы робот взял своим захватом, на стол. Объект появится в `RViz` как узкая желтая коробка, расположенная между двумя оранжевыми коробками. Как нам уже известно из предыдущих демонстраций, мы можем передвинуть захват между этими коробками, если сообщим ему заранее вычисленную позицию. Однако более реалистичный сценарий – вывести нужную позицию из позиции целевого объекта. MoveIt! еще не может делать этого автоматически, но другие предоставили нам утилиты, облегчающие работу.

Основная задача заключается в том, чтобы создать коллекцию подходящих позиций захвата, которые могут подойти. Так как мы знаем позицию целевого объекта, мы можем попробовать набор позиций с центром в объекте и выровненных в соответствии с его ориентацией. У этих пробных позиций будет изменяться тангаж \(pitch\), рысканье \(yaw\) и \(возможно\) крен \(roll\), пока MoveIt! не обнаружит что данная позиция может быть достигнута без столкновений с целевым объектом и другими препятствиями.

Следующее изображение показывает ориентацию и позицию виртуальной системы координат, прикрепленной к  `right_gripper_link`:

![](.gitbook/assets/3.png)

Помните, что мы определили эту систему координат для целей планирования и разместили оси между двумя пальцами захвата, там, где, как правило, захватывается объект. Из изображения видно, что мы хотим выровнять эту систему координат относительно целевого объекта \(окрашен в желтый\) и разместить ее начало у его центра.

Перед тем как изучить код, давайте проверим его в симуляции. Если Pi Robot еще не запущен в ArbotiX симуляторе, запустите его сейчас:

```bash
$ roslaunch rbx2_bringup pi_robot_with_gripper.launch sim:=true 
```

Далее, запустите файл `move_group.launch` робота Pi Robot, если он еще не запущен:

```bash
$ roslaunch pi_robot_moveit_config move_group.launch 
```

Теперь запустите `RViz` с конфигурационным файлом `pick_and_place.rviz`: 

```bash
$ rosrun rviz rviz -d `rospack find rbx2_arm_nav`/config/pick_and_place.rviz
```

Наконец, запустите сценарий `moveit_pick_and_place.demo.py`: 

```bash
$ rosrun rbx2_arm_nav moveit_pick_and_place_demo.py 
```

Как и при демонстрации препятствий, сценарий сначала добавляет летающий стол и две коробки в сцену. Также он добавляет узкую коробку между двумя существующими и она задается целевым объектом для операции поднятия и размещения. После генерации некоторого количества тестовых захватов, рука передвигается в подходящую позицию для поднятия цели. Далее захват сжимается вокруг цели и цель помещается в новую локацию на столе. 

**ПРИМЕЧАНИЕ 1**: Вы заметите что движение захваченного объекта затормаживает движение захвата. Этот артефакт вызван еще не найденной ошибкой или ограничениями плагина MoveIt! для `RViz`. Движение объекта можно сгладить ценой дерганного движения руки, изменив следующие настройки `RViz`:

•	В **Scene Robot**, измените значение **Alpha** с 0 на 1 

•	Снимите флаг с дисплея **RobotModel**

После этого запустите демонстрацию заново. В этот раз движение руки не будет таким плавным, но захваченный объект будет двигаться синхронно с захватом.

**ПРИМЕЧАНИЕ 2**: Возможно, операция поднятия или размещения будет провалена после пяти попыток, разрешенных сценарием. Это иногда случается, если IK solver не может найти способ передвинуть захват или захватываемый объект. Мы обсудим методы повышения шансов на успех далее. Пока что, просто запускайте сценарий заново до тех пор, пока операция не удастся.

Так как сценарий `moveit_pick_and_place_demo.py` похож на `moveit_obstacles_demo.py`, рассмотренный ранее, мы сосредоточимся только на новых вещах.

**Ссылка на источник**: `moveit_pick_and_place_demo.py`

Начнем с новых операторов импорта: 

```python
 from moveit_msgs.msg import Grasp, GripperTranslation, MoveItErrorCodes 
```

Для начала, нам нужно импортировать типы сообщений `Grasp`, `GripperTranslation` и `MoveItErrorCodes`. Сообщение типа `Grasp` будет использовано для определения списка возможных позиций для захвата, которые следует попробовать. Сообщение типа `GripperTranslation` позволяет уточнить направление приближения, а также минимальное и максимальное желаемое расстояние подхода. `MoveItErrorCodes` позволяет проверять успешность операции поднятия или размещения. Больше деталей далее.

from tf.transformations import quaternion\_from\_euler 

Мы также импортируем функцию `quaternion_from_euler` библиотеки `tf` так как мы будем переводить некоторые углы Эйлера в кватернионы.\]

```python
GROUP_NAME_ARM = 'right_arm' 
 GROUP_NAME_GRIPPER = 'right_gripper'  
GRIPPER_FRAME = 'right_gripper_link' 
 GRIPPER_CLOSED = [-0.06] 
 GRIPPER_OPEN = [0.05] 
 GRIPPER_NEUTRAL = [0.0]  GRIPPER_JOINT_NAMES = 
['right_gripper_finger_joint'] 
 GRIPPER_EFFORT = [1.0] 
 REFERENCE_FRAME = 'base_footprint'
```

 Мы определяем несколько глобальных переменных для хранения имен различных link, систем отсчета и joint. Также они могут быть считаны при помощи параметров ROS. Величины, указанные для трех позиций захвата \(closed, open и neutral\) были определены эмпирически.

```python
self.gripper_pose_pub = rospy.Publisher('gripper_pose', PoseStamped) 
```

Во время отладки иногда бывает полезно визуализировать позиции захвата, которые были опробованы во время попыток поднять целевой объект. Здесь мы определяем издателя, который позволит нам публиковать различные позиции в топике "`gripper_pose`". После этого мы можем подписаться на этот топик в `RViz` для просмотра позиций.

```python
# Установим ограничение количества попыток взятия
 max_pick_attempts = 5 
         
 # Установим ограничение количества попыток размещения
 max_place_attempts = 5 
```

Операция поднятия и размещения MoveIt! не обязательно будет успешной с первой попытки, поэтому мы задаем максимальное количество попыток отдельно для операций поднятия и размещения.

```python
target_size = [0.02, 0.01, 0.12] 
```

Так же как мы делали это для стола и коробок, мы определяем длину, ширину и высоту целевого объекта. В этом случае мы создаем узкую коробку высотой 12 см со сторонами 2 см x 1 см.

```python
# Установим целевую полицию между коробками на столе
 target_pose = PoseStamped() 
 target_pose.header.frame_id = REFERENCE_FRAME  target_pose.pose.position.x = 0.22  target_pose.pose.position.y = 0.0 
 target_pose.pose.position.z = table_ground + table_size[2] + target_size[2] /  
2.0  target_pose.pose.orientation.w = 1.0          
 # Добавим целевой объект в сцену 
 scene.add_box(target_id, target_pose, target_size) 
```

Здесь мы задаем позицию цели таким образом, что она оказывается на столе между двумя коробками. После мы добавляем цель в сцену, используя функцию `add_box()`.

```python
  # Зададим имя поддерживающей поверхности как имя стола
   right_arm.set_support_surface_name(table_id) 
```

Когда объекты были добавлены в сцену, мы задаем стол в качестве поддерживающей поверхности \(support surface\) для операций поднятия и размещения. Это позволяет MoveIt! не учитывать предупреждение о столкновении при размещении объекта обратно на стол. 

```python
# Укажем позицию в которую нужно разместить цель после поднятия
place_pose = PoseStamped() 
 place_pose.header.frame_id = REFERENCE_FRAME  place_pose.pose.position.x = 0.18  place_pose.pose.position.y = -0.18 
place_pose.pose.position.z = table_ground + table_size[2] + target_size[2] / 2.0 
 place_pose.pose.orientation.w = 1.0 
```

 После мы уточняем локацию, куда мы хотим разместить цель после захвата роботом. Определенная выше позиция находится на столе справа от правой коробки \(вид со стороны робота\). Присваивая ориентации единичный кватернион, мы указываем, что объект должен быть расположен вертикально.

```python
# Инициализируем позицию захвата позой цели  
grasp_pose = target_pose 
```

Операция поднятия MoveIt! требует предоставления по крайней мере одной возможной позиции захвата, которая может подойти для удерживания целевого объекта. На самом деле, мы предоставим множество различных позиций захвата, но начнем с той, что соответствует позиции цели. 

```python
# Сдвинем позицию захвата на половину ширины цели для центрирования
  grasp_pose.pose.position.y -= target_size[1] / 2.0 
```

Здесь мы смещаем изначальную позицию захвата немного вправо от центра цели. Единственная причина заключается в том, что Pi Robot двигает только правый палец, в то время как его левый палец зафиксирован. Небольшое смещение по направлению к зафиксированному пальцу даст более центрированный захват. Если вы используете параллельный захват с двумя сервоприводами \(по одному на каждый палец\) или призматический joint, двигающий оба пальца вместе при помощи одного сервопривода, такая корректировка не будет необходимой.  

```python
# Создадим список захватов 
 grasps = self.make_grasps(grasp_pose, [table_id]) 
```

Как мы говорили ранее, мы создадим множество позиций захвата, которые MoveIt! будет пытаться использовать во время операции поднятия. Здесь мы используем функцию `make_grasps()`, которую мы опишем в деталях далее. Функция принимает два аргумента: изначальная позиция захвата, которую следует опробовать и список ID объектов, к которым захват может прикасаться во время приближения к цели. В данном случае мы позволяем дотрагиваться до стола. Функция `make_grasps()` возвращает список возможных позиций захвата цели.

```python
for grasp in grasps:      
self.gripper_pose_pub.publish(grasp.grasp_pose)      rospy.sleep(0.2) 
```

Как было объяснено ранее, иногда бывает полезно визуализировать позиции захвата цели в `RViz`. Тут мы публикуем каждую позицию, чтобы при необходимости их можно было быстро увидеть.

```python
# Следим за успешностью/провалом операции и номером попытки
result = None 
n_attempts = 0          
 # Повторяем пока не преуспеем или не закончатся попытки 
 while result != 
MoveItErrorCodes.SUCCESS and n_attempts < max_pick_attempts:      result = right_arm.pick(target_id, grasps)      n_attempts += 1 
     rospy.loginfo("Pick attempt: " +  str(n_attempts))      rospy.sleep(0.2) 
```

Наконец мы дошли до части, где мы пытаемся поднять целевой объект используя наш список позиций захвата. Сначала мы устанавливаем флаг для проверки `result`, который позволит выйти из цикла если мы найдем подходящую позицию захвата. Так же мы подсчитываем количество раз прохода по коллекции захватов \(`n_attempts`\). Обратите внимание что каждая попытка задействует проход по всему списку захватов. Из-за случайных отклонений, существующих во внутренних IK алгоритмах и алгоритмах подъема, зачастую оказывается полезно проходить по списку более одного раза, если предыдущие попытки оказались неудачными.

Сама операция подъема – строчка `result = right_arm.pick(target_id, grasps)`. Функция `pick()` принимает два аргумента: id объекта, который нужно захватить и список позиций захвата, которые следует попробовать. Если один из захватов успешно проходит тесты на достижимость с избеганием столкновений, операция `pick()` возвращает `SUCCESS` и позволяет нам выйти из цикла. Успешный `pick()` откроет захват во время передвижения руки к цели и закроет его, достигнув цели. Если максимальное возможное количество попыток превышено, также происходит выход из цикла.

Если объект успешно поднят, мы переходим к операции размещения, как показано ниже. 

```python
# Если поднятие было успешно, пробуем разместить
if result == MoveItErrorCodes.SUCCESS: 
     result = None  
    n_attempts = 0 
             
     # Создаем корректные позиции для размещения   
   places = self.make_places(place_pose)
```

Сначала мы сбрасываем флаг `result` и количество попыток. После мы используем вспомогательную функцию `make_places()`, определенную далее в сценарии для создания списка поз – кандидатов для позиций размещения объекта. Мы передаем `make_places()` желаемую `place_pose`, которую мы ранее определили в сценарии как аргумент. Функция после возвращает список позиций, схожих с целевой позицией, возможно немного отличающихся расположением и/или ориентацией, которые дадут IK solver больше шансов на успех.

```python
while result != MoveItErrorCodes.SUCCESS and n_attempts < 
max_place_attempts:      for place in places:          result = right_arm.place(target_id, place)          if result == 
MoveItErrorCodes.SUCCESS:              break      n_attempts += 1      rospy.loginfo("Place attempt: " +  str(n_attempts))      
rospy.sleep(0.2)
```

Здесь мы выполняем цикл, похожий на тот, что использовался для `pick()`.  Сама операция `place()` происходит в строке `result = right_arm.place(target_id, place)`. В отличие от функции `pick()`, `place()` принимает единственную позицию вместо списка позиций в качестве аргумента. Поэтому мы вручную проходим по нашему списку целевых мест и вызываем `place()` для каждой из них. Если операция `place()` определяет, что объект может быть успешно передвинут в указанную позицию, рука разместит объект в этой позиции и захват отпустит этот объект.

По сути, это завершает сценарий. Далее рассмотрим вспомогательную функцию `make_grasps()`. 

```python
1	def make_grasps(self, initial_pose_stamped, allowed_touch_objects): 
2	# Инициализируем объект захвата 
3	g = Grasp() 
4         
5	# Устанавливаем позы перед захватом и во время захвата соответственно 
6	g.pre_grasp_posture = self.make_gripper_posture(GRIPPER_OPEN)
7	g.grasp_posture = self.make_gripper_posture(GRIPPER_CLOSED) 
8         
9	# Устанавливаем параметры приближения и отхода какими мы хотим
10	g.pre_grasp_approach = self.make_gripper_translation(0.01, 0.1, [1.0,  0.0, 0.0]) 
11	g.post_grasp_retreat = self.make_gripper_translation(0.1, 0.15, [0.0, -1.0, 1.0]) 
12         
13	# Приравниваем первую из позиций захвата введенной позиции
14	g.grasp_pose = initial_pose_stamped 
15     
16	# Величины тангажа, которые будут опробованы
17	pitch_vals = [0, 0.1, -0.1, 0.2, -0.2, 0.3, -0.3] 
18	         
19	# Величины рысканья, которые будут опробованы
20	 	yaw_vals = [0] 
21 
22	# Список который будет хранить захваты 
23	grasps = [] 
24 
25        # Создаем позицию захвата для каждой пары тангажа и рысканья
26        for y in yaw_vals: 
27	for p in pitch_vals: 
28	# Создаем кватернион из углов Эйлера 
29	q = quaternion_from_euler(0, p, y) 
30                 
31	# Устанавливаем позицию захвата соответственно 
32	g.grasp_pose.pose.orientation.x = q[0] 
33	g.grasp_pose.pose.orientation.y = q[1] 
34	g.grasp_pose.pose.orientation.z = q[2] 
35	g.grasp_pose.pose.orientation.w = q[3] 
36                 
37                # Устанавливаем id для этого захвата (просто должно быть уникальным) 
38                g.id = str(len(grasps)) 
39                 
40	# Устанавливаем объекты которых можно касаться из входного списка
41	g.allowed_touch_objects = allowed_touch_objects 
42                 
43	# Не ограничиваем силу контакта 
44	g.max_contact_force = 0 
45                 
46	# Уменьшаем качество захвата для увеличивающегося тангажа 
47	g.grasp_quality = 1.0 - abs(p) 
48                 
49	# Добавляем захват в список 
50	grasps.append(deepcopy(g)) 
51                 
52 	# Возвращаем список 
53 	return grasps 
```

Функция `make_grasps()` была заимствована из пакета `chessbox` за авторством Michael Ferguson. Сообщение MoveIt! `Grasp` требует позу перед захватом \(открытую\) и ухватившую позу \(закрытую\), вектор приближения захвата \(направление, по которому захват должен приближаться к цели\) и вектор отхода \(направление движения захвата после того как объект был взят\).

Держа в уме эти требования, давайте рассмотрим функцию `make_grasps()` построчно. 

```python
3         g = Grasp() 
```

Сначала мы инициализируем переменную `g` как объект `Grasp`.

```python
6	g.pre_grasp_posture = self.make_gripper_posture(GRIPPER_OPEN) 
7	g.grasp_posture = self.make_gripper_posture(GRIPPER_CLOSED)
```

После мы устанавливаем `pre_grasp_posture` для захвата как открытую позицию, а ухватившую позу как закрытую позицию. Обратите внимание что мы используем другую вспомогательную функцию, названную  `make_gripper_posture()`, тоже определенную в сценарии, ее мы рассмотрим позднее.

```python
10	g.pre_grasp_ap7proach = self.make_gripper_translation(0.01, 0.1, [1.0, 0.0, 0.0]) 
11	g.post_grasp_retreat = self.make_gripper_translation(0.1, 0.15, [0.0, -1.0, 1.0]) 
```

Здесь мы определяем вектора приближения и отхода, используя вспомогательную функцию `make_gripper_translation()`, рассмотренную ниже. Эта функция принимает три параметра: минимальное расстояние, желаемое расстояние и вектор направления, описанный как список из `x`, `y` и `z` компонент.

В строке 10 мы указываем чтобы захват приближался вдоль направления `x`, \[1.0, 0.0, 0.0\], которое совпадает с прямым направлением базовой системы отсчета, так как робот находится за целью. Мы указываем минимальное расстояние сближения как 1 см, а желаемое расстояние равное 10 см. 

Аналогично, в строке 11 объявляется направление отхода вверх и вправо, \[0.0, -1.0, 1.0\], так как мы хотим поднять объект над одной из коробок и передвинуть его вправо от нее. Еще здесь мы задаем минимальную дистанцию отхода равную 10 см и желаемую дистанцию равную 15 см.

```python
14        g.grasp_pose = initial_pose_stamped 
```

После мы приравниваем `grasp_pose` объекта захвата к начальной позе, переданной в `make_grasps()` как аргумент. Помните, что мы передавали в функцию позу целевого объекта. 

```python
16 	# Величины тангажа, которые будут опробованы
17 	pitch_vals = [0, 0.1, -0.1, 0.2, -0.2, 0.4, -0.4] 
18         
19 	# Величины рысканья, которые будут опробованы
20 	yaw_vals = [0] 
```

Далее создадим некоторое количество альтернативных позиций захвата с разными значениями тангажа и \(опционально\) рысканья. Списки `pitch_vals` и `yaw_vals` выше показывают углы, которые будут опробованы \(в радианах\). Обратите внимание что в этом случае мы будем изменять только тангаж. Вы так же можете добавить параметр крена если считаете это необходимым.

```python
25        # Создаем позицию захвата для каждой пары тангажа и рысканья
26        for y in yaw_vals: 
27	for p in pitch_vals: 
28	# Создаем кватернион из углов Эйлера
20                q = quaternion_from_euler(0, p, y)
```

Для каждого значения рысканья и тангажа мы создадим кватернион из двух Эйлеровских компонент с помощью функции `quaternion_from_euler`, импортированной в начале сценария.

```python
32 	g.grasp_pose.pose.orientation.x = q[0] 
33 	g.grasp_pose.pose.orientation.y = q[1] 
34 	g.grasp_pose.pose.orientation.z = q[2] 
35 	g.grasp_pose.pose.orientation.w = q[3] 
```

После мы устанавливаем компоненты позиции захвата равными компонентам найденного кватерниона. 

```python
38                g.id = str(len(grasps)) 
```

Каждая позиция захвата должная иметь уникальный `id`, поэтому мы просто устанавливаем его равным длине списка захватов, который возрастает на один каждый раз при добавлении новой позиции. 

```python
41                g.allowed_touch_objects = allowed_touch_objects 
```

Захвату может быть задан список объектов, которых он может касаться. В нашем случае, мы разрешим захвату дотрагиваться до стола если это потребуется для приближения к цели. Помните, что на место аргумента `allowed_touch_objects` функции `make_grasps()` мы передали список `[table_id]` для того чтобы разрешить захвату дотрагиваться до стола.

```python
44                g.max_contact_force = 0 
```

Если бы мы управляли настоящей рукой, мы бы установили адекватное значения максимума силы соприкосновения, но так как мы работаем в симуляции, это значение мы устанавливаем равному нулю. 

```python
47                g.grasp_quality = 1.0 - abs(p) 
```

Операция поднятия MoveIt! ожидает что кандидаты на успешную позицию захвата будут классифицированы по качеству. Здесь мы считаем, что наше начальное предположение \(позиция цели\) имеет высочайшее качество \(1.0\), которое соответствует значению тангажа 0. Для других значений тангажа, мы уменьшаем качество, отнимая модуль тангажа от 1.0, это отражает тот факт, что мы не ожидаем что высокие значения тангажа обязательны.

```python
50                grasps.append(deepcopy(g)) 
```

Наконец, мы добавляем позицию захвата к списку позиций. Мы используем функцию `deepycopy()` Python чтобы обеспечить добавление по настоящему различной копии объекта `g`.  Иначе, компоненты `g` будут содержать только ссылки на предыдущую версию `g` из предыдущего прохода по циклу.

```python
53        return grasps 
```

После того как список позиций был создан, он возвращается вызывающей программе. 

Функция `make_grasps()` использует две вспомогательные функции, `make_gripper_posture()` и `make_gripper_translation()`.  Давайте их рассмотрим. 

```python
1	def make_gripper_posture(self, joint_positions): 
2	# Инициализируем траекторию joint для joint захвата
3	    t = JointTrajectory() 
4         
5	# Устанавливаем имена joint как имена joint захвата
6	t.joint_names = GRIPPER_JOINT_NAMES 
7         
8        # Инициализируем траекторию joint представляющую цель
9        tp = JointTrajectoryPoint() 
10         
11        # Присваиваем позицям joint траектории полученные значения
12       tp.positions = joint_positions 
13         
14	# Устанавливаем усилие захвата
15	tp.effort = GRIPPER_EFFORT 
16         
17        # Добавляем целевую точку к точкам траектории 
18        t.points.append(tp) 
19         
20	# Возвращаем траекторию joint 
21	return t 
```

Функция `make_gripper_posture()` достаточно понятна, она принимает целевую позу захвата в виде списка позиций joint и возвращает траекторию joint, которая передвинет пальцы в нужную позицию. В нашем случае, мы используем эту функцию чтобы превратить позиции `OPEN` и `CLOSED` в открывающие и закрывающие траектории, которые будут использоваться при приближении к целевому объекту и при его захвате по достижение цели.

```python
1	def make_gripper_translation(self, min_dist, desired, vector): 
2	# Инициализируем объект перехода захвата 
3	g = GripperTranslation() 
4         
5	# Приравниваем компоненты вектора направления к полученным 
6	g.direction.vector.x = vector[0] 
7	g.direction.vector.y = vector[1] 
8	g.direction.vector.z = vector[2] 
9         
10	# Система отсчета вектора такая же как у захвата
11	g.direction.header.frame_id = GRIPPER_FRAME 12         
13	# Устанавливаем минимальное и желаемое расстояние из параметров
14	g.min_distance = min_dist 
15	g.desired_distance = desired 
16         
17        return g 
```

Функция `make_gripper_translation()` так же достаточно проста. Помните, что мы использовали эту функцию для определения векторов приближения и отхода захвата при движении к объекту и при переносе его в новую позицию.

Наконец, функция `make_places()` была использована для создания некоторого количества альтернативных позиций для размещения объекта на столе.

```python
1 	def make_places(self, init_pose): 
2 	# Инициализируем локацию как сообщение PoseStamped 
3 	place = PoseStamped() 
4         
5 	# Начинаем с позиции из параметров 
6 	place =  init_pose 
7         
8 	# Список смещений по x (в метрах), которые следует попробовать 
9 	x_vals = [0, 0.005, 0.01, 0.015, -0.005, -0.01, -0.015] 
10         
11 	# Список смещений по y (в метрах), которые следует попробовать
12 
13 	y_vals = [0, 0.005, 0.01, 0.015, -0.005, -0.01, -0.015]        
14        # Список тангажей, которые следует попробовать
15         
16        pitch_vals = [0] 
17         
18	# Список рысканий, которые следует попробовать
19	yaw_vals = [0] 
20 
21	# Список для хранения мест 
22	places = [] 
23         
24        # Создадим позицию места для каждого варианта отклонений
25        for y in yaw_vals: 
26	for p in pitch_vals: 
27	for y in y_vals: 
28	for x in x_vals: 
29	place.pose.position.x = init_pose.pose.position.x + x
30	                      place.pose.position.y = init_pose.pose.position.y + y 
31                         
32	# Создадим кватернион из углов Эйлера
33	q = quaternion_from_euler(0, p, y) 
34                         
35	# Установим ориентацию позиции места соответствующе 
36	place.pose.orientation.x = q[0] 
37	place.pose.orientation.y = q[1] 
38	place.pose.orientation.z = q[2] 
39	place.pose.orientation.w = q[3] 
40                         
41	# Добавим эту позицию места в список 
42	places.append(deepcopy(place)) 
43         
44	# Вернем список
45	return places 
```

Как вы можете видеть, эта функция очень похожа на `make_grasps()`, которая была детально описана выше. Вместо того чтобы возвращать список позиций захвата, отличающихся ориентацией, мы возвращаем список позиций мест, находящихся рядом с желаемым целевым местом. 



