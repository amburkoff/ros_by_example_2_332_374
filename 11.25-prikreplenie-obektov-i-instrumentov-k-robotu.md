# 11.25  Прикрепление объектов и инструментов к роботу

Представьте, что ваш робот держит инструмент или другой объект \(возможно, это световой меч?\) и вы хотите, чтобы этот объект учитывался при проверке на столкновения во время планирования. MoveIt! предоставляет простой способ этого достичь при помощи функций `attach_box()` и `attach_mesh()`. Они позволяют прикрепить желаемый объект к роботу. После того, как объект был прикреплен, любые последующие команды движения будут учитывать размер и форму этого объекта.

Демонстрационный сценарий `moveit_attached_object_demo.py` показывает, как прикрепить продолговатый инструмент к захвату робота Pi Robot, и как после этого передвинуть руку в позицию “`straight_forward` ”, а затем в положение покоя, избегая столкновений инструмента с летающим столом. 

Перед тестированием убедитесь в том, что запущена поддельная версия Pi Robot и запущен файл `move_group.launch`. Если `Rviz` уже запущен, перезапустите его с конфигурационным файлом `attached_object.rviz`:

```bash
$ rosrun rviz rviz -d `rospack find rbx2_arm_nav`/config/attached_object.rviz
```

После запустите демонстрационный сценарий: 

```bash
$ rosrun rbx2_arm_nav moveit_attached_object_demo.py 
```

Прикрепленный объект станет фиолетовым если прикрепление произошло успешно. После открепления он опять станет зеленым. Обратите внимание, как движение руки учитывает прикрепленный объект и предотвращает его столкновения с другими объектами и частями робота.

**ПРИМЕЧАНИЕ**: Достаточно дерганное движение руки в этой демонстрации вызвано еще не найденной ошибкой или ограничениями в скорости обновления плагина MoveIt! для `Rviz`. Настоящая рука будет двигаться плавно. 

Первая часть сценария такая же, как и в `moveit_obstacles_demo.py`, поэтому мы не будем повторять ее здесь. Ключевые строки для прикрепления объекта к end-effector следуют далее: 

```python
60    # Задаем длину, ширину и высоту объекта для прикрепления
61    tool_size = [0.3, 0.02, 0.02] 
62     
63	# Создаем позицию для инструмента относительно end-effector
64	p = PoseStamped() 
65	p.header.frame_id = end_effector_link 
66     
67	# Распологаем конец объекта в захват 
68	p.pose.position.x = tool_size[0] / 2.0 - 0.025 
69	p.pose.position.y = 0.0 
70	p.pose.position.z = 0.0 
71     
72    # Выравниваем объект
73    p.pose.orientation.x = 0 
74	p.pose.orientation.y = 0 
75	p.pose.orientation.z = 0 
76	p.pose.orientation.w = 1 
77     
78	# Прикрепляем инструмент к end-effector 
79	scene.attach_box(end_effector_link, 'tool', p, tool_size) 
```

В строке 62 мы задаем размеры прямоугольного инструмента, устанавливая длину 0.3 метра, ширину и высоту 0.02 метра.

Строки 64-67 определяют позицию инструмента относительно end-effector. Используемая здесь позиция ориентирует инструмент параллельно пальцам захвата, и направляет его наружу руки. Чтобы инструмент был захвачен у конца, мы сдвигаем его на  ½ своей длины, таким образом, что его конец оказывается у концов пальцев захвата, после этого сдвигаем его обратно на 2.5 см, чтобы захват взял его.

Наконец, в строке 79 используется функция `attach_box()` объекта scene для прикрепления нашего инструмента к end-effector. Функция принимает четыре аргумента: link, к которому мы хотим присоединить объект; строковое имя, присваиваемое объекту, который мы присоединяем \(чтобы можно было в дальнейшем по нему ссылаться на объект\); поза, определяющая положение объекта относительно link; размер коробки, которую мы присоединяем, заданная как длина, ширина и высота. Пятым необязательным аргументом является список link, контакт с которыми не будет считаться столкновением \(touch links\).

Все настолько просто. Остальная часть сценария лишь помещает руку в “выпрямленную” позицию, а затем в положение покоя. MoveIt! заботится о планировании движения с учетом прикрепленного к end-effector объекта.

Вместо использования функции `attach_box()`, так же можно использовать `attach_mesh()` для присоединения STL или Collada mash-объекта, находящегося в файле. Порядок аргументов в этому случае такой: `attach_mesh(link, object_name, pose, filename, touch_links=[])`. 

Ближе к концу сценария, мы открепляем инструмент от end-effector с помощью выражения:

```python
102    scene.remove_attached_object(end_effector_link, 'tool')  
```

Обратите внимание как мы ссылаемся на инструмент по имени, которое мы ранее ему дали во время прикрепления. Так же заметьте что функция `remove_attached_object()`, как и `attach_box()`, принадлежит объекту `scene`. 



